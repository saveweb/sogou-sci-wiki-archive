<!DOCTYPE html><html class="" data-reactroot=""><head><meta charSet="utf-8"/><meta name="save" content="history"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><meta name="baidu-site-verification" content="VWGb6TyYx8"/><meta content="选择排序 - 搜狗科学百科" name="keywords"/><meta content="搜狗科学百科是一部有着平等、协作、分享、自由理念的网络科学全书，为每一个互联网用户创造一个涵盖所有领域知识、服务的中文知识性平台。" name="description"/><meta http-equiv="x-dns-prefetch-control" content="on"/><meta name="server" baike="235" ip="210" env="online"/><link rel="dns-prefetch" href="//cache.soso.com"/><link rel="dns-prefetch" href="//hhy.sogoucdn.com"/><link rel="dns-prefetch" href="//pic.baike.soso.com"/><link rel="dns-prefetch" href="//ugc.qpic.cn"/><link rel="dns-prefetch" href="//xui.ptlogin2.qq.com"/><link rel="dns-prefetch" href="//q1.qlogo.cn"/><link rel="dns-prefetch" href="//q2.qlogo.cn"/><link rel="dns-prefetch" href="//q3.qlogo.cn"/><link rel="dns-prefetch" href="//q4.qlogo.cn"/><link rel="dns-prefetch" href="//q.qlogo.cn"/><link rel="dns-prefetch" href="//img01.sogoucdn.com"/><link rel="dns-prefetch" href="//img02.sogoucdn.com"/><link rel="dns-prefetch" href="//img03.sogoucdn.com"/><link rel="dns-prefetch" href="//img04.sogoucdn.com"/><link rel="Shortcut Icon" href="//www.sogou.com/images/logo/new/favicon.ico?v=4"/><link rel="Bookmark" href="//www.sogou.com/images/logo/new/favicon.ico?v=4"/><link href="//hhy.sogoucdn.com/deploy/ued/new_baike/pc/dist/css/base_b849887.css" rel="stylesheet"/><link href="//hhy.sogoucdn.com/deploy/ued/new_baike/pc/dist/css/detail/detail_378aed5.css" rel="stylesheet"/><link href="//hhy.sogoucdn.com/deploy/ued/new_baike/pc/dist/css/inviteAudit/inviteAudit_7894507.css" rel="stylesheet"/><link rel="stylesheet" href="//hhy.sogoucdn.com/js/lib/highlight/highlight.min.css"/><title>选择排序 - 搜狗科学百科</title></head><body><script>window._gtag=window._gtag||{};window._gtag.shouldGrayed = false;if ('47767ce6fa2a41c7807b9847952638e6') window._gtag.traceId = '47767ce6fa2a41c7807b9847952638e6';if ({"illegality":true}) window.userInfo = {"illegality":true};</script><div class="topnavbox"><ul class="topnav"><li><a href="//www.sogou.com/web?query=">网页</a></li><li><a href="//weixin.sogou.com/weixin?p=75351201">微信</a></li><li><a href="//zhihu.sogou.com/zhihu?p=75351218">知乎</a></li><li><a href="//pic.sogou.com/pics?query=">图片</a></li><li><a href="//v.sogou.com/v?query=">视频</a></li><li><a href="//mingyi.sogou.com/">医疗</a></li><li class="cur"><strong>科学</strong></li><li><a href="//hanyu.sogou.com/">汉语</a></li><li><a href="//wenwen.sogou.com/">问问</a></li><li><a href="//www.sogou.com/docs/more.htm">更多<span class="topraquo">»</span></a></li></ul></div><div id="header"><div class="header-wrap"><a class="header-logo" href="/kexue"></a><div class="header-search"><div class="querybox" id="suggBox"></div></div><div class="header-rgt"><span class="btn-header-rgt btn-edit" id="editLemma">创建</span><div class="header-user no-login"></div></div></div></div><div class="fixed-placeholder" style="visibility:none"></div><div id="container" class=""><div class="content lemma-level1"><div class="detail-title" id="abstract-title"><h1>选择排序</h1><a href="#!" class="detail-edit">编辑</a></div><div class="section_content" data-id="68805506927505931"><div class="text_img ed_imgfloat_right"><a class="ed_image_link" data-src="https://img01.sogoucdn.com/app/a/200698/811_248_20201218163337-1102903850.gif" data-bigsrc="https://img01.sogoucdn.com/app/a/200698/811_248_20201218163337-1102903850.gif?width=231&amp;height=174&amp;titlename=%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E5%8A%A8%E7%94%BB&amp;w=811&amp;h=248" title="点击查看大图" data-w="811" data-h="248" style="background-image:url(https://img01.sogoucdn.com/app/a/200698/811_248_20201218163337-1102903850.gif)" href="#!"></a><div class="text_img_title">选择排序动画</div></div><div><p>选择排序（Selection sort）是计算机科学发展早期的经典排序算法，因其每次选择数据中的一个极值进行排序而得名。</p>
<p>其基本思路是将数据分为无序区与有序区，初始时有序区为空，多次遍历无序区，每次遍历从无序区中选择最大或最小值放入有序区一端，直到所有数据归入有序区结束排序<sup><a href="#quote_1" class="kx_ref">[1]</a></sup><sup><a href="#quote_2" class="kx_ref">[2]</a></sup>。常见的选择排序算法使用交换无序区一端与所选数据实现选择数据归入有序区的过程，因此<strong>通常来说选择排序是不稳定的</strong>排序方法。</p></div></div><div id="catalog"></div><div id="paragraphs"></div><div id="references"></div><div id="recommendReferences"></div><div class="read-num">阅读 <!-- -->869</div></div><div class="right-side" id="rightSide"></div></div><div class="footer-box"><div id="footer"><div class="footer-logo-wrap"><div class="footer-logo"></div><div class="footer-logo-text">知识·传播·科普</div></div><div class="footer-info">本网站内容采用<a target="_blank" href="https://creativecommons.org/licenses/by-sa/3.0/deed.zh?tdsourcetag=s_pctim_aiomsg">CC-BY-SA 3.0</a>授权</div><div class="footer-btn-wrap"><a target="_blank" href="https://baike.sogou.com/help/#user_protocol">用户协议</a><a target="_blank" href="http://www.sogou.com/docs/terms.htm?v=1">免责声明</a><a target="_blank" href="http://corp.sogou.com/private.html">隐私政策</a><a target="_blank" href="https://baike.sogou.com/kexue/intro.htm">关于我们</a></div></div></div><script>window.lemmaInfo ={"lemmaId":"19764407546422533","versionId":"69534526270943503","title":"选择排序","subtitle":"","abstracts":{"paragraphId":"68805506927505931","title":"摘要","versionId":"69534526270943504","lemmaId":19764407546422532,"createType":0,"creator":{"uid":0,"name":null,"pic":null,"introduction":null,"educations":null,"jobs":null,"works":null,"educationBrief":null,"jobBrief":null,"role":0,"roleName":null,"title":null,"professionalTitle":null,"phoneNo":null,"editable":false,"partnerId":0,"partnerIdCreateTime":0,"partnerIdPoped":false},"createTime":0,"versionEditor":{"uid":77798521,"name":"张擎天","pic":null,"introduction":null,"educations":null,"jobs":null,"works":null,"educationBrief":null,"jobBrief":null,"role":0,"roleName":null,"title":null,"professionalTitle":null,"phoneNo":null,"editable":false,"partnerId":0,"partnerIdCreateTime":0,"partnerIdPoped":false},"editTime":1608741807,"comment":null,"dependVersionId":0,"contentType":2,"content":"<p>选择排序（Selection sort）是计算机科学发展早期的经典排序算法，因其每次选择数据中的一个极值进行排序而得名。</p>\n<p>其基本思路是将数据分为无序区与有序区，初始时有序区为空，多次遍历无序区，每次遍历从无序区中选择最大或最小值放入有序区一端，直到所有数据归入有序区结束排序<sup><a href=\"#quote_1\" class=\"kx_ref\">[1]</a></sup><sup><a href=\"#quote_2\" class=\"kx_ref\">[2]</a></sup>。常见的选择排序算法使用交换无序区一端与所选数据实现选择数据归入有序区的过程，因此<strong>通常来说选择排序是不稳定的</strong>排序方法。</p>","pics":[{"originalUrl":"https://img01.sogoucdn.com/app/a/200698/811_248_20201218163337-1102903850.gif?width=231&height=174&titlename=%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E5%8A%A8%E7%94%BB&w=811&h=248","url":"https://img01.sogoucdn.com/app/a/200698/811_248_20201218163337-1102903850.gif","rw":811,"rh":248,"title":"选择排序动画","alt":null,"width":231,"height":174}],"card":null,"references":[],"versionCount":0},"card":{"paragraphId":"68805506910728714","title":"基本信息","versionId":"68805506910728709","lemmaId":19764407546422532,"createType":0,"creator":{"uid":0,"name":null,"pic":null,"introduction":null,"educations":null,"jobs":null,"works":null,"educationBrief":null,"jobBrief":null,"role":0,"roleName":null,"title":null,"professionalTitle":null,"phoneNo":null,"editable":false,"partnerId":0,"partnerIdCreateTime":0,"partnerIdPoped":false},"createTime":0,"versionEditor":{"uid":77798521,"name":"张擎天","pic":null,"introduction":null,"educations":null,"jobs":null,"works":null,"educationBrief":null,"jobBrief":null,"role":0,"roleName":null,"title":null,"professionalTitle":null,"phoneNo":null,"editable":false,"partnerId":0,"partnerIdCreateTime":0,"partnerIdPoped":false},"editTime":1608307277,"comment":null,"dependVersionId":0,"contentType":3,"content":"","pics":null,"card":{"cardItems":[{"key":"中文名","value":"选择排序"},{"key":"外文名","value":"Selection sort"},{"key":"最坏时间复杂度","value":"O（n²）"},{"key":"最好时间复杂度","value":"O（n²）"},{"key":"平均时间复杂度","value":"O（n²）"},{"key":"空间复杂度","value":"O（1）"},{"key":"算法稳定性","value":"常见不稳定"},{"key":"排序类型","value":"比较"}]},"references":[],"versionCount":0},"categories":[{"id":326,"name":"算法理论","parents":[[{"id":1,"name":"计算机","parents":null},{"id":322,"name":"计算机基础学科","parents":null}]]}],"creator":{"uid":10145103,"name":"柚子otto","pic":"https://img02.sogoucdn.com/app/a/200698/1152_1152_1864088_20200427232849-1518843971.png","introduction":"","educations":[{"schoolName":"中国地质大学（北京）","major":"","degree":"本科","universityId":22,"universityLogo":"https://img01.sogoucdn.com/app/a/200943/d3465c1c-6011-11e9-b353-fc4dd4f70029","majorLevel1":"理学","majorLevel2":"地理学","majorLevel3":"地图学与地理信息系统","majorLevel1Id":1,"majorLevel2Id":103,"majorLevel3Id":109,"state":"毕业","lab":"","researchField":""}],"jobs":[{"company":"搜狗","title":"产品经理"}],"works":null,"educationBrief":"中国地质大学（北京）","jobBrief":"产品经理","role":0,"roleName":null,"title":"中国地质大学（北京） · 地理学本科","professionalTitle":null,"phoneNo":null,"editable":true,"partnerId":139,"partnerIdCreateTime":1595844881,"partnerIdPoped":true},"createTime":1579076504,"editor":{"uid":77798521,"name":"张擎天","pic":"https://thirdwx.qlogo.cn/mmopen/vi_32/qftso2tiat4ZAkdP2AAhFVFNtIreDuAlIzZP1ko6eeficgqqPx9z3STDgzAUVCRdat3woUYyrVbwqDiaaTqUnZ21g/132","introduction":null,"educations":[{"schoolName":"电子科技大学","major":"","degree":"硕士","universityId":92,"universityLogo":"https://img01.sogoucdn.com/app/a/200943/595b5a2e-6013-11e9-922c-fc4dd4f70029","majorLevel1":"理学","majorLevel2":"计算机科学与技术","majorLevel3":"计算机科学与技术","majorLevel1Id":1,"majorLevel2Id":316,"majorLevel3Id":319,"state":"在读","lab":"","researchField":""}],"jobs":null,"works":null,"educationBrief":"电子科技大学","jobBrief":"","role":0,"roleName":null,"title":"电子科技大学 · 计算机科学与技术硕士","professionalTitle":null,"phoneNo":null,"editable":true,"partnerId":0,"partnerIdCreateTime":1593569000,"partnerIdPoped":false},"editTime":1608741807,"state":1,"versionCount":2,"upNum":10,"downNum":0,"pics":[{"originalUrl":"https://img01.sogoucdn.com/app/a/200698/811_248_20201218163337-1102903850.gif?width=231&height=174&titlename=%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E5%8A%A8%E7%94%BB&w=811&h=248","url":"https://img01.sogoucdn.com/app/a/200698/811_248_20201218163337-1102903850.gif","rw":811,"rh":248,"title":"选择排序动画","alt":null,"width":231,"height":174}],"catalogs":[{"level":1,"title":"算法原理","paragraphId":"68805506927505930","subCatalogs":null},{"level":1,"title":"代码示例","paragraphId":"68805506927505929","subCatalogs":[{"level":2,"title":"C语言范例","paragraphId":"68805506927505929","subCatalogs":null},{"level":2,"title":"其他语言范例","paragraphId":"68805506927505929","subCatalogs":null}]},{"level":1,"title":"算法分析","paragraphId":"68805506910728715","subCatalogs":[{"level":2,"title":"时间复杂度","paragraphId":"68805506910728715","subCatalogs":null},{"level":2,"title":"空间复杂度","paragraphId":"68805506910728715","subCatalogs":null},{"level":2,"title":"算法稳定性","paragraphId":"68805506910728715","subCatalogs":null}]},{"level":1,"title":"参考文献","paragraphId":"-1","subCatalogs":null},{"level":1,"title":"推荐文献","paragraphId":"68805506910728716","subCatalogs":null}],"paragraphs":[{"paragraphId":"68805506927505930","title":"算法原理","versionId":"69534526270943505","lemmaId":19764407546422532,"createType":0,"creator":{"uid":0,"name":null,"pic":null,"introduction":null,"educations":null,"jobs":null,"works":null,"educationBrief":null,"jobBrief":null,"role":0,"roleName":null,"title":null,"professionalTitle":null,"phoneNo":null,"editable":false,"partnerId":0,"partnerIdCreateTime":0,"partnerIdPoped":false},"createTime":0,"versionEditor":{"uid":77798521,"name":"张擎天","pic":null,"introduction":null,"educations":null,"jobs":null,"works":null,"educationBrief":null,"jobBrief":null,"role":0,"roleName":null,"title":null,"professionalTitle":null,"phoneNo":null,"editable":false,"partnerId":0,"partnerIdCreateTime":0,"partnerIdPoped":false},"editTime":1608741807,"comment":null,"dependVersionId":0,"contentType":1,"content":"<p>选择排序算法的基本思想是假设有N个元素需要排序，将所有元素分为有序区和无序区，初始情况下有序区为空，现在进行N-1次遍历，每次遍历逐个比较无序区中元素，选择一个最值加入有序区，直到无序区所有元素进入有序区。</p><p>值得注意的是选择排序算法是一种思想，其可以实现在集合到数组的排序转换，数组的排序，链表的排序等。因使用的场景和数据结构不同，其特性有不同的差异。使用数组实现的选择排序也可以实现稳定的排序，但是时间复杂度会达到O（n3）使其不再具有实用意义，这里不做过多讨论。</p><p>使用数组元素交换实现的不稳定选择排序过程（以升序排列为例）：</p><p>\n <ol>\n  <li><p>初始状态：无序区为Ri[1..n]，有序区Rj为空。</p></li>\n  <li><p>第1趟排序——在无序区Ri[1..n]中选出关键字最小的记录R[k]，将它与无序区的第1个记录R[1]交换，使有序区Rj[1]和无序区Ri[2..n]分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区。</p></li>\n  <li><p>第i趟排序——当前有序区和无序区分别为Ri[1..i-1]和Rj[i..n]。该趟排序从当前无序区中选出关键字最小的记录 R[k]，将它与无序区的第1个记录R[i]交换，使有序区Rj[1..i]和无序区Ri[i+1..n]分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区。</p></li>\n  <li><p>第n-1趟排序——当前有序区和无序区分别为Ri[1..n-2]和Rj[n-1..n]。该趟排序从比较R[n-1]和R[n]，选择最小值与R[n-1]交换，此轮遍历后有序区变为Rj[1..n-1]，无序区变为Ri[n]，无序区只有一个元素因此将无序区标记为有序区，整个遍历结束。</p></li>\n </ol></p><p>使用单向链表实现的稳定选择排序过程（以升序排列为例）：</p><p>\n <ol>\n  <li><p>初始状态：无序区为Ri[1..n]，有序区Rj为空。</p></li>\n  <li><p>第1趟排序——在无序区Ri[1..n]中选出关键字最大的记录Ri[k]，将它从无序区中删除放到有序区Rj[1]中，无序区减少一个元素变为Ri[1..n-1]，有序区增加一个元素成为Rj[1]。</p></li>\n  <li><p>第i趟排序——当前有序区和无序区分别为Ri[1..n-i+1]和Rj[1..i-1]。该趟排序从当前无序区中选出关键字最大的记录 Ri[k]，将它从无序区中删除放到有序区头部成为Rj[1]，无序区减少一个元素变为Ri[1..n-i]，有序区增加一个元素成为Rj[1..i]。</p></li>\n  <li><p>第n趟排序——当前有序区和无序区分别为Ri[1]和Rj[1..n-1]。该趟排序将Ri[1]放入有序区头部成为Rj[1]，此轮遍历后有序区变为Rj[1..n-1]，无序区变为空，整个遍历结束。</p></li>\n </ol></p>","pics":null,"card":null,"references":[],"versionCount":0},{"paragraphId":"68805506927505929","title":"代码示例","versionId":"69534526270943506","lemmaId":19764407546422532,"createType":0,"creator":{"uid":0,"name":null,"pic":null,"introduction":null,"educations":null,"jobs":null,"works":null,"educationBrief":null,"jobBrief":null,"role":0,"roleName":null,"title":null,"professionalTitle":null,"phoneNo":null,"editable":false,"partnerId":0,"partnerIdCreateTime":0,"partnerIdPoped":false},"createTime":0,"versionEditor":{"uid":77798521,"name":"张擎天","pic":null,"introduction":null,"educations":null,"jobs":null,"works":null,"educationBrief":null,"jobBrief":null,"role":0,"roleName":null,"title":null,"professionalTitle":null,"phoneNo":null,"editable":false,"partnerId":0,"partnerIdCreateTime":0,"partnerIdPoped":false},"editTime":1608741807,"comment":null,"dependVersionId":0,"contentType":1,"content":"<p><h3>C语言范例</h3></p><p>选择排序在数组的实现：</p><p><pre data-lang=\"c_cpp\" class=\"kx_code\" contenteditable=\"false\">//输入为数组numArray，数组大小numLength\nvoid select_sort(int *numArray,int numLength)\n{\n    register int i, j, minPos, temp;\n    for(i = 0; i &lt; numLength-1; i++)\n    {\n        //初始最小值索引设为i\n        minPos = i;\n        \n        //查找无序区最小值\n        for(j = i + 1; j &lt; numLength; j++)\n            if(numArray[minPos] &gt; numArray[j])\n                minPos = j;//更新最小值索引\n        \n        //当需要交换时，实现值的交换        \n        if(minPos != i)\n        {\n            temp = numArray[minPos];\n            numArray[minPos] = numArray[i];\n            numArray[i] = temp;\n            \n            //以下是常见节约temp空间做法,算术\n            //numArray[minPos]=numArray[minPos]+numArray[i]；\n            //numArray[i]=numArray[minPos]-numArray[i]；\n            //numArray[minPos]=numArray[minPos]-numArray[i]；\n            \n            //使用异或交换更快 适合int，char\n            //numArray[minPos]=numArray[minPos]^numArray[i]；\n            //numArray[i]=numArray[minPos]^numArray[i]；\n            //numArray[minPos]=numArray[minPos]^numArray[i]；\n       }\n     }\n}</pre></p><p>选择排序在链表的实现：</p><p><pre data-lang=\"c_cpp\" class=\"kx_code\" contenteditable=\"false\">//链表节点结构体\nstruct node{\n    int data;\n    struct node *next;\n}; \n\n//在原链表中遍历找排最后的最大值结点，找到之后就把它从原链表中抽出来用头插法加到新的链表中。 \n//输入值若包含不带数据的头节点需要提前去掉\nstruct node * selectSort(struct node *head){\n    \n    //headNew：新链表的头指针；\n    //max：原链表中最大的结点指针；\n    //premax：最大结点的前驱结点的指针；\n    //t：用于遍历原链表寻找最大结点的临时指针;\n    //pret:t的前驱结点临时指针\n    struct node *headNew, *max, *premax, *t, *pret;\n    headNew = NULL;\n    \n    //遍历找原链表中当前最大结点 \n    while (head)\n    {\n        max = head;\n        premax = NULL;\n        pret = head;\n        t = head-&gt;next;\n        \n        //1、寻找无序区最末尾最大结点 \n        while (t){\n            if (t-&gt;data &gt;= max-&gt;data){\n                max=t;\n                premax=pret;\n            }\n            pret = t;\n            t = t-&gt;next;    \n        }\n        \n        //2、当最大值不是第一个节点时，从无序区删除节点\n        if (max != head)\n            premax-&gt;next = max-&gt;next;\n            \n        //3、把此结点头插法插入新链表\n        max-&gt;next = headNew;\n        headNew = max;\n        \n        //4、移动头指针完成一轮循环\n        head = head-&gt;next;\n    }\n    return headNew;\n}</pre></p><p><h3>其他语言范例</h3></p><p>C#</p><p><pre data-lang=\"c_cpp\" class=\"kx_code\" contenteditable=\"false\">static void sort(int[]group)\n{\n    int temp;\n    int pos=0;\n    for(int i=0;i&lt; group.Length-1;i++)\n    {\n        pos=i;\n        for(intj=i+1;j&lt;group.Length;j++)\n        {\n            if(group[j]&lt;group[pos])\n            {\n                pos=j;\n            }\n        }//第i个数与最小的数group[pos]交换\n        temp=group[i];\n        group[i]=group[pos];\n        group[pos]=temp;\n    }\n}</pre></p><p>Java<br></p><p><pre data-lang=\"java\" class=\"kx_code\" contenteditable=\"false\">public void xuanzeSort(int[] array){\n    for(int i=0;i&lt;array.length-1;i++){\n        int min = i;\n        for(int j = i+1;j&lt;array.length;j++){\n            if(array[j]&lt;array[min]){\n                min = j;\n            }\n        }\n        if(i != min){\n            int tmp = array[min];\n            array[min] = array[i];\n            array[i] = tmp;\n        }\n    }\n}</pre></p><p>Go<br></p><p><pre data-lang=\"golang\" class=\"kx_code\" contenteditable=\"false\">func SelectionSort(nums []int32) {\n    length := len(nums)\n    for i := 0; i &lt; length; i++ {\n        min := i\n        for j := i + 1; j &lt; length; j++ {\n            if nums[j] &lt; nums[min] {\n                min = j\n            }\n        }\n        temp := nums[i]\n        nums[i] = nums[min]\n        nums[min] = temp\n    }\n    fmt.Println(nums)\n}</pre></p><p>Python<br></p><p><pre data-lang=\"python\" class=\"kx_code\" contenteditable=\"false\">def selection_sort(list2):\n  for i in range(0, len (list2)-1):\n    min_ = i\n    for j in range(i + 1, len(list2)):\n      if list2[j] &lt; list2[min_]:\n        min_ = j\n    list2[i], list2[min_] = list2[min_], list2[i]</pre></p><p>Perl<br></p><p><pre data-lang=\"makefile\" class=\"kx_code\" contenteditable=\"false\">#!/usr/bin/perl\nsubselect_sort{\n    my(*array)=@_;\n    $length=@array;\n    for($i=0;$i&lt;$length-1;$i++)\n    {\n        $min=$i;\n        for($j=$i+1;$j&lt;$length;$j++)\n        {\n            if($array[$j]&lt;$array[$min])\n            {\n                $min=$j;\n            }\n            if($min!=$i)\n            {\n                $temp=$array[$i];\n                $array[$i]=$array[$min];\n                $array[$min]=$temp;\n            }\n        }\n        return@array;\n    }</pre></p><p>PHP<br></p><p><pre data-lang=\"php\" class=\"kx_code\" contenteditable=\"false\">function selection_sort($array){\n    $count=count($array);\n    for($i=0;$i&lt;$count-1;$i++){\n        /*findtheminest*/\n        $min=$i;\n        echo'$min--&gt;'.$array[$min].'--&gt;';\n        for($j=$i+1;$j&lt;$count;$j++){\n            //由小到大排列\n            if($array[$min]&gt;$array[$j]){\n                //表明当前最小的还比当前的元素大\n                $min=$j;\n                //赋值新的最小的\n            }\n        }\n        echo$array[$min].'coco&lt;br/&gt;';\n        /*swap$array[$i]and$array[$min]即将当前内循环的最小元素放在$i位置上*/\n        if($min!=$i){\n            $temp=$array[$min];\n            $array[$min]=$array[$i];\n            $array[$i]=$temp;\n        }\n    }\n    return$array;\n}\n$old_array=array(3,4,5,6,8,2,12);\n$new_array=selection_sort($old_array);\nprint_r($new_array);</pre></p><p>Ruby<br></p><p><pre data-lang=\"ruby\" class=\"kx_code\" contenteditable=\"false\">def selection_sort(array)  \n  result = []  \n  array.size.times { result &lt;&lt; array.delete_at(array.index(array.min)) } \n  result\nend</pre></p><p>更多可参见<sup><a href=\"#quote_3\" class=\"kx_ref\">[3]</a></sup></p>","pics":null,"card":null,"references":[],"versionCount":0},{"paragraphId":"68805506910728715","title":"算法分析","versionId":"69534526270943507","lemmaId":19764407546422532,"createType":0,"creator":{"uid":0,"name":null,"pic":null,"introduction":null,"educations":null,"jobs":null,"works":null,"educationBrief":null,"jobBrief":null,"role":0,"roleName":null,"title":null,"professionalTitle":null,"phoneNo":null,"editable":false,"partnerId":0,"partnerIdCreateTime":0,"partnerIdPoped":false},"createTime":0,"versionEditor":{"uid":77798521,"name":"张擎天","pic":null,"introduction":null,"educations":null,"jobs":null,"works":null,"educationBrief":null,"jobBrief":null,"role":0,"roleName":null,"title":null,"professionalTitle":null,"phoneNo":null,"editable":false,"partnerId":0,"partnerIdCreateTime":0,"partnerIdPoped":false},"editTime":1608741807,"comment":null,"dependVersionId":0,"contentType":1,"content":"<p><h3>时间复杂度</h3></p><p>选择排序的时间复杂度与数据的熵（有序度）无关，无论数据是否有序，选择排序都需要进行<br></p><div contenteditable=\"false\" class=\"kx_formula\" alt=\"N%3D(n-1)%2B(n-2)%2B...%2B2%2B1%3D%5Cfrac%7Bn*(n-1)%7D%7B2%7D%20\"><img class=\"svgFormula\" src=\"https://pic02.sogoucdn.com/s3/a/100520084/baike/edit-formula/0f9d867f69074337278724d3ff99176da7d412d6df776679cf0d34fb8cf2b61b.svg\" style=\"vertical-align: -1.552ex;\"></div><p>次比较，因此在所有情况下时间复杂度均为O(n2)。</p><p>对于使用数组实现的选择排序，如果已经有序，交换0次；最坏情况交换n-1次，逆序交换n/2次。在计算机系统中赋值操作消耗的时间远大于比较操作，因此，在数据量少的情况下，选择排序是快于冒泡排序的算法。</p><p><h3>空间复杂度</h3></p><p>基于不同的选择排序实现方式，对于常见数组实现最少需要使用2个指针记录需要交换的地址，在此种情况下选择排序的空间复杂度为O(1)；对于链表实现，通常需要使用6个指针记录相关位置信息，在此种情况下择排序的空间复杂度为O(1)。</p><p><h3>算法稳定性</h3></p><p>对于常见数组实现因为可能产生破环稳定性的交换操作，在此种情况下，选择排序是不稳定的。</p><p>例如，需要排序的数组为A-2，B-2，C-1；当第一次遍历时，C-1作为最小值，将会与A-2进行位置交换，交换完成后序列为C-1，B-2，A-2，经过第二次遍历后没有元素被调整，排序结束。最终AB的相对位置改变，稳定性被破坏。</p><p>对于链表实现，不会产生交换操作，在此种情况下，选择排序是稳定的。</p><p>同样的例子需要排序的数组为A-2，B-2，C-1：</p><p>当第一次遍历时，B-2作为最大值，将会放入有序区头部，此时有序区为B-2，无序区为A-2，C-1。</p><p>当第二次遍历时，A-2作为最大值，将会放入有序区头部，此时有序区为A-2，B-2，无序区为C-1。</p><p>当第三次遍历时，C-1作为最大值，将会放入有序区头部，此时有序区为C-1，A-2，B-2，无序区为空。</p><p>最终AB的相对位置没有改变，此种选择排序算法为稳定排序算法。</p>","pics":null,"card":null,"references":[],"versionCount":0}],"references":[{"id":1,"type":"web","title":"通俗易懂讲解 选择排序","site":"知乎专栏","url":"https://zhuanlan.zhihu.com/p/29889599","journalName":null,"author":"","press":"","publishYear":"","publishTime":"","publishPlace":"","page":"","volume":"","quoteTime":"2020-12-24","quoted":false},{"id":2,"type":"book","title":" 数据结构与算法分析: C 语言描述. ","site":"","url":"","journalName":null,"author":"维斯MA.","press":"人民邮电出版社","publishYear":"2005.","publishTime":null,"publishPlace":"","page":"","volume":"","quoteTime":"","quoted":false},{"id":3,"type":"web","title":"JS-Sorting-Algorithm","site":"GitHub","url":"https://github.com/hustcc/JS-Sorting-Algorithm","journalName":null,"author":"","press":"","publishYear":"","publishTime":"","publishPlace":"","page":"","volume":"","quoteTime":"2020-12-24","quoted":false}],"recommendReferences":{"paragraphId":"68805506910728716","title":"推荐文献","versionId":"69534526270943508","lemmaId":19764407546422532,"createType":0,"creator":{"uid":0,"name":null,"pic":null,"introduction":null,"educations":null,"jobs":null,"works":null,"educationBrief":null,"jobBrief":null,"role":0,"roleName":null,"title":null,"professionalTitle":null,"phoneNo":null,"editable":false,"partnerId":0,"partnerIdCreateTime":0,"partnerIdPoped":false},"createTime":0,"versionEditor":{"uid":77798521,"name":"张擎天","pic":null,"introduction":null,"educations":null,"jobs":null,"works":null,"educationBrief":null,"jobBrief":null,"role":0,"roleName":null,"title":null,"professionalTitle":null,"phoneNo":null,"editable":false,"partnerId":0,"partnerIdCreateTime":0,"partnerIdPoped":false},"editTime":1608741807,"comment":null,"dependVersionId":0,"contentType":4,"content":"","pics":null,"card":null,"references":[{"id":1,"type":"book","title":" 数据结构与算法分析: C 语言描述. ","site":"","url":"","journalName":null,"author":"维斯MA.","press":"人民邮电出版社","publishYear":"2005.","publishTime":null,"publishPlace":"","page":"","volume":"","quoteTime":"","quoted":true},{"id":2,"type":"book","title":"Data structures and algorithm analysis in C++","site":"","url":"","journalName":null,"author":"WM Allen","press":"Pearson Education India","publishYear":"2007","publishTime":null,"publishPlace":"","page":"","volume":"","quoteTime":"","quoted":false}],"versionCount":0},"auditState":2,"lemmaLevel":1,"origin":2,"originEnTitle":null,"originZhTitle":"选择排序","pv":869,"auditType":1,"synonyms":null,"showEditTime":"2020.12.24 00:43","auditors":[{"uid":83469325,"name":"王玉磊","pic":"https://cache.soso.com/wenwen/i/default-thumb.png","introduction":null,"educations":[{"schoolName":"澳门科技大学","major":"","degree":"博士","universityId":611,"universityLogo":"https://img01.sogoucdn.com/app/a/200909/9a4a771c-2071-11e9-9507-961dc4e9823e","majorLevel1":"理学","majorLevel2":"计算机科学与技术","majorLevel3":"计算机科学与技术","majorLevel1Id":1,"majorLevel2Id":316,"majorLevel3Id":319,"state":"在读","lab":"","researchField":""},{"schoolName":"澳门科技大学","major":"","degree":"硕士","universityId":611,"universityLogo":"https://img01.sogoucdn.com/app/a/200909/9a4a771c-2071-11e9-9507-961dc4e9823e","majorLevel1":"理学","majorLevel2":"计算机科学与技术","majorLevel3":"计算机科学与技术","majorLevel1Id":1,"majorLevel2Id":316,"majorLevel3Id":319,"state":"毕业","lab":"","researchField":""},{"schoolName":"北京科技大学","major":"","degree":"本科","universityId":16,"universityLogo":"https://img01.sogoucdn.com/app/a/200943/04d8a30c-6012-11e9-8ce7-fc4dd4f70029","majorLevel1":"理学","majorLevel2":"数学","majorLevel3":"数学与信息技术","majorLevel1Id":1,"majorLevel2Id":2,"majorLevel3Id":12,"state":"毕业","lab":"","researchField":""}],"jobs":[{"company":"北京大学中国社会科学调查中心（2015-2016）","title":"数据分析师"}],"works":null,"educationBrief":"澳门科技大学","jobBrief":"数据分析师","role":0,"roleName":null,"title":"澳门科技大学 · 计算机科学与技术博士","professionalTitle":"博士研究生在读","phoneNo":null,"editable":true,"partnerId":273,"partnerIdCreateTime":1607679266,"partnerIdPoped":true},{"uid":220012,"name":"思明","pic":"https://cache.soso.com/qlogo/g?b=oidb&k=cquZ3H4l5tJt7m8ZWXibvpg&s=100&t=1557929484","introduction":"","educations":null,"jobs":null,"works":null,"educationBrief":"","jobBrief":"","role":0,"roleName":null,"title":"","professionalTitle":"","phoneNo":null,"editable":true,"partnerId":201,"partnerIdCreateTime":1595845027,"partnerIdPoped":true}],"hasZhishiNav":false,"auditInfos":{"0":[{"versionId":"0","auditTime":1608953241,"auditorId":83469325,"auditUser":{"uid":83469325,"name":"王玉磊","pic":"https://cache.soso.com/wenwen/i/default-thumb.png","introduction":null,"educations":[{"schoolName":"澳门科技大学","major":"","degree":"博士","universityId":611,"universityLogo":"https://img01.sogoucdn.com/app/a/200909/9a4a771c-2071-11e9-9507-961dc4e9823e","majorLevel1":"理学","majorLevel2":"计算机科学与技术","majorLevel3":"计算机科学与技术","majorLevel1Id":1,"majorLevel2Id":316,"majorLevel3Id":319,"state":"在读","lab":"","researchField":""},{"schoolName":"澳门科技大学","major":"","degree":"硕士","universityId":611,"universityLogo":"https://img01.sogoucdn.com/app/a/200909/9a4a771c-2071-11e9-9507-961dc4e9823e","majorLevel1":"理学","majorLevel2":"计算机科学与技术","majorLevel3":"计算机科学与技术","majorLevel1Id":1,"majorLevel2Id":316,"majorLevel3Id":319,"state":"毕业","lab":"","researchField":""},{"schoolName":"北京科技大学","major":"","degree":"本科","universityId":16,"universityLogo":"https://img01.sogoucdn.com/app/a/200943/04d8a30c-6012-11e9-8ce7-fc4dd4f70029","majorLevel1":"理学","majorLevel2":"数学","majorLevel3":"数学与信息技术","majorLevel1Id":1,"majorLevel2Id":2,"majorLevel3Id":12,"state":"毕业","lab":"","researchField":""}],"jobs":[{"company":"北京大学中国社会科学调查中心（2015-2016）","title":"数据分析师"}],"works":null,"educationBrief":"澳门科技大学","jobBrief":"数据分析师","role":0,"roleName":null,"title":"澳门科技大学 · 计算机科学与技术博士","professionalTitle":"博士研究生在读","phoneNo":null,"editable":true,"partnerId":273,"partnerIdCreateTime":1607679266,"partnerIdPoped":true},"auditReason":null,"auditSuggest":"内容完整，逻辑顺畅，后期可以对相关的其他语言实现添加必要的注释。作者也可以整理编辑更多相关的排序算法。","auditResult":2,"auditAnnotations":[]},{"versionId":"0","auditTime":1609120548,"auditorId":220012,"auditUser":{"uid":220012,"name":"思明","pic":"https://cache.soso.com/qlogo/g?b=oidb&k=cquZ3H4l5tJt7m8ZWXibvpg&s=100&t=1557929484","introduction":"","educations":null,"jobs":null,"works":null,"educationBrief":"","jobBrief":"","role":0,"roleName":null,"title":"","professionalTitle":"","phoneNo":null,"editable":true,"partnerId":201,"partnerIdCreateTime":1595845027,"partnerIdPoped":true},"auditReason":null,"auditSuggest":"根据评审员的建议给予通过。","auditResult":2,"auditAnnotations":[]}]},"isHistory":false};</script><script crossorigin="anonymous" src="//hhy.sogoucdn.com/aegis-sdk/latest/aegis.min.js"></script><script crossorigin="anonymous" src="//hhy.sogoucdn.com/js/common/polyfill/main_2020092401.js"></script><script crossorigin="anonymous" src="//hhy.sogoucdn.com/js/lib/react/17.0.2/react.production.min.js"></script><script crossorigin="anonymous" src="//hhy.sogoucdn.com/js/lib/react/17.0.2/react-dom.production.min.js"></script><script crossorigin="anonymous" src="//hhy.sogoucdn.com/js/lib/jquery/jquery-1.11.1.min.js"></script><script crossorigin="anonymous" src="//hhy.sogoucdn.com/js/common/hhy/main_2022062701.js"></script><script crossorigin="anonymous" src="//hhy.sogoucdn.com/js/deploy/new_baike/pc/general/main_66bbe21.js"></script><script crossorigin="anonymous" src="//hhy.sogoucdn.com/js/lib/react/17.0.2/react.production.min.js"></script><script crossorigin="anonymous" src="//hhy.sogoucdn.com/js/lib/react/17.0.2/react-dom.production.min.js"></script><script crossorigin="anonymous" src="//hhy.sogoucdn.com/js/deploy/new_baike/pc/detail/main_edf0f08.js"></script><div id="popControl"></div></body></html>